#!/usr/bin/perl -w -CSDA

use strict;
use utf8;
use v5.010;
use Unicode::Collate;
use Storable;
# use Term::ANSIColor qw(:constants);

if ($#ARGV < 1){
  say "Usage:   $0 dictionary regex";
  say "Example: $0 photius ^κη.*ος";
  exit;
}

my $dict = shift @ARGV;
my $search_regex = shift @ARGV;

my $uc = Unicode::Collate->new();
my $dict_file = $dict . '.dsl';
my $dict_index = $dict.'.idx';
my %w_index;
my @w_matches;
my $max_matches = 20;                            # Maximum lemata to return

&dict_indexer($dict) unless -e $dict_index;      # Generate index if not there

# say $search_regex;
say "";

%w_index = %{retrieve($dict_index)};

my $n = 0;                                       # Lema counter
foreach my $d_head ( keys %w_index){
  if ($d_head =~ m/$search_regex/){
      push @w_matches, $d_head;
      $n++;
  }
  last if $n >= $max_matches;
}
open (IN, '<', $dict_file) or die $!;
foreach ($uc->sort( @w_matches)){
  my ($idx, $word) = @{$w_index{$_}};            # [index, word]
  seek IN, $idx, 0;
  my $body = "";
  while(1){
    my $line = <IN> ;
    last unless $line =~ /\[m\d\]/;
    $line =~ s/\s*\[\/?m\d?\]//g;
    # chomp $line;
    $body .= $line;
  }
  # $body =~ s/\s*\[\/?m\d?\]//g;
  &colour($body);                                # Markups -> colour
  # &decolour($body);                            # Remove colour markups.

  print "\x1b[35;1m", $word, "\x1b[0m", ": ";
  print "$body\n";
}
close IN;
# say foreach @w_matches;

#-----------------------------------------------------------
sub colour
{
  # $_[0] =~ s/\[c.*?\]/\x1b[36;1m/g;
  $_[0] =~ s/\[c limegreen\]/\x1b[32;1m/g;
  $_[0] =~ s/\[c darkblue\]/\x1b[34;1m/g;
  $_[0] =~ s/\[c darkmagenta\]/\x1b[35;1m/g;
  $_[0] =~ s/\[c maroon\]/\x1b[31;1m/g;
  $_[0] =~ s/\[c gray\]/\x1b[36;1m/g;
  $_[0] =~ s/\[c red]//g;
  $_[0] =~ s/\[\/c\]/\x1b[0m/g;
  $_[0] =~ s/\[b\]/\x1b[35;1m/g;
  $_[0] =~ s/\[\/b\]/\x1b[0m/g;
  $_[0] =~ s/\[\/?i\]//g;
  $_[0] =~ s/\\\[/\[/g;
  $_[0] =~ s/\\\]/\]/g;

}
sub decolour
{
  $_[0] =~ s/\[\/?c.*?\]//g;
  $_[0] =~ s/\[\/?b\]//g;

}
#-----------------------------------------------------------

sub dict_indexer
{
  my $dict = shift @_;
  my $dict_idx = $dict . '.idx';


  my %w_index;
  my %dups;
  my $offset = 0;


  open (IN, '<', $dict . '.dsl') or die $!;
  while (<IN>) {
    next if /#/;
    unless (/^\t/){
      $offset = tell(IN);
      my $head = $_;
      chomp $head;         # dos files may need: s/(\n|\r)//g
      $head =~ s/\x{feff}//;
      my $d_head = &detone($head);
      unless (exists $w_index{$d_head}){
        $w_index{$d_head} = [$offset, $head];
      }else{
        if (exists($dups{$d_head})){
          $dups{$d_head}++;
          $w_index{$d_head . "-" ."$dups{$d_head}"} = [$offset, $head];
        }else{
          $dups{$d_head} = 1;
          $w_index{$d_head . "-1"} = [$offset, $head];
        }
      }
    }
  }
  store \%w_index, $dict_idx;
  close IN;
  say "$dict.dsl indexed -> $dict_idx";
  return;
}

#-----------------------------------------------------------

sub detone
{
  my $word = shift @_;
  $word =~ tr/ἀἁάάὰᾶἄἂἆἅἃἇᾳᾀᾄᾂᾆᾁᾅᾃᾇΑἈἉΆΆᾺἌἊἎἍἋἏ/α/;
  $word =~ tr/ἐἑέέὲἔἒἕἓΕἘἙΈΈῈἜἚ/ε/;
  $word =~ tr/ἠἡήήὴῆἤἢἦἥἣἧῃᾐᾔᾒᾖᾑᾕᾓᾗΗἨἩΉΉῊἬἪἮἭἫἯ/η/;
  $word =~ tr/ἰἱίίὶῖἴἲἶἵἳἷϊΙἸἹΊΊῚἼἺἾἽἻἿ/ι/;
  $word =~ tr/ὀὁόόὸὄὂὅὃΟὈὉΌΌῸὌὊὍὋ/ο/;
  $word =~ tr/ὐὑύύὺῦὔὒὖὕὓὗϋΥὙΎΎῪὝὛὟ/υ/;
  $word =~ tr/ὠὡώώὼῶὤὢὦὥὣὧῳᾠᾡᾤᾢᾦᾥᾣᾧΩὨὩΏΏῺὬὪὮὭὫὯ/ω/;
  $word =~ tr/ῥῤῬΡ/ρ/;
  $word =~ tr/ΒΓΔΖΘΚΛΜΝΞΠΡΣΤΦΧΨ/βγδζθκλμνξπρστφχψ/;
  $word =~ s/’//g;
  return $word;
}

