#!/usr/bin/perl -w -CSDA

use strict;
use utf8;
use v5.022;
use DBI;
use File::Slurp;                              # qw(read_dir);
use Getopt::Long;
use Encode qw( decode_utf8 );                 # Needed for SQLite greek text
use File::Basename;
use lib dirname (__FILE__);                   # or  . "other/path/to/modules";
use Lectus;
&usage unless scalar(@ARGV);                  # Error return if no args at all

my $index_flag = 0;
my $max_matches = 20;  # TODO: implement the limit. # Maximum lemmata to return
my @dicts;
my $dict_dir = "./dictionaries";
my $idx_dir = "./idx/";
my $db_table = "word_index";

GetOptions(
  'index'                 => \$index_flag,
  'lexica=s{1,}'          => \@dicts,
  'directory=s'           => \$dict_dir,
) or &usage;                                  # Error return if otions fault

$dict_dir =~ s/$/\// unless $dict_dir =~ m/\/$/;  # append / if not there

if ($index_flag){                              # call indexer and exit
  &dict_indexer($dict_dir);
  exit 0;
}
&usage unless scalar(@ARGV);                  # Error return if no search term

unless (scalar @dicts){                       # Look for DSLs in $dict_dir
  @dicts = grep {/\.dsl/} read_dir("$dict_dir");
  @dicts = map { (my $s = $_) =~ s/\.dsl//; $s} @dicts;
}

my $search = &detone(lc(shift @ARGV));        # Only the search term is left in ARGV

foreach my $dict (@dicts){
  my $dict_file = $dict_dir . $dict . '.dsl';
  die "$dict_file not found" unless -e $dict_file;
  my $dict_index = $idx_dir . $dict . '.db';
  die "$dict_index not found" unless -e $dict_index;
  my $dsn = qq(DBI:SQLite:dbname=$dict_index;,,,{ RaiseError=>1, AutoCommit=>1});
  my $dbh = DBI->connect($dsn) or die $DBI::errstr;

  my $sql = qq{SELECT HEAD, HEADWORD, OFFSET FROM $db_table WHERE HEAD LIKE ? };
  my $sth = $dbh->prepare($sql) or die ("Cannot Prepare:  " . $DBI::errstr);
  $sth->execute($search) or die("Cannot Execute: " . $DBI::errstr);

  my @w_matched = sort{ $a->[0] cmp $b->[0] } @{$sth->fetchall_arrayref()};


  if (scalar @w_matched){
    print "\x1b[33;1m$dict\x1b[0m:\n";
  } else {
    print "\x1b[33;1m$dict\x1b[0m: -\n";
    next;                                         # Stop if nothing in index
  }

  open (IN, '<', $dict_file) or die $!;
  foreach ( @w_matched) {
    my ($head, $word, $idx) = @$_;
    seek IN, $idx, 0;
    my $body = "";
    while(1){
      my $indent = 1;                                # default value
      my $line = <IN> ;
      last unless $line =~ /\t(?:\[(m\d?)\])?/;
      my $level = $1;
      if ($level)
      {
        $indent = 1 if $level eq 'm0';
        $indent = 2 if $level eq 'm1';
        $indent = 4 if $level eq 'm2';
        $indent = 8 if $level eq 'm3';
        $indent = 10 if $level eq 'm4';
      }
      $line =~ s/\s*\[\/?m\d?\]//g;
      &colour_Ansi($line);                                # Markups -> colour
      $body .= ( ' ' x $indent) . $line;
      # last unless $regex_flag;
    }
    print "\x1b[35;1m", decode_utf8($word), "\x1b[0m", ": ";
    print "$body\n";
  }
  close IN;
  $dbh->disconnect();
} # --- end foreach $dic

#-----------------------------------------------------------
#               Subroutines
#-----------------------------------------------------------


sub usage
{
  print << 'EOT';
  +--------------------------------------------------------------------------+
  |                                                                          |
  |                                                                          |
  |     Usage:  ./lectus <lemma>  [option]                                   |
  |                                                                          |
  |     OPTIONS:                                                             |
  |     -i or --index               Index all dictionaries                   |
  |     -l or --lexica              Space separated list of dictionaries     |
  |     -d or --directory           Path to the dictionaries directory       |
  |                                 Default directory path:  ./              |
  |                                                                          |
  +--------------------------------------------------------------------------+
EOT
die;
}
