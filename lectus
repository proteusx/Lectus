#!/usr/bin/perl -w -CSDA

use strict;
use utf8;
use v5.022;
use DBI;
use File::Slurp;                              # qw(read_dir);
use Getopt::Long;
use Data::Dumper;
use Encode qw( decode_utf8 );                 # Needed for SQLite greek text
use experimental 'smartmatch';                # silence smartmatch (~~) warning;
&usage unless scalar(@ARGV);                  # Error return if no args at all

my $index_flag = 0;
my $max_matches = 20;                          # Maximum lemata to return
my @dicts;
my $dict_dir = "./dictionaries";
my $idx_dir = "./idx/";
my $db_table = "word_index";

GetOptions(
  'index'                 => \$index_flag,
  'lexica=s{1,}'          => \@dicts,
  'directory=s'           => \$dict_dir,
) or &usage;                                  # Error return if otions fault

$dict_dir =~ s/$/\// unless $dict_dir =~ m/\/$/;  # append / if not there

if ($index_flag){                              # call indexer and exit
  &dict_indexer($dict_dir);
  exit 0;
}
&usage unless scalar(@ARGV);                  # Error return if no search term

unless (scalar @dicts){                       # Look for DSLs in $dict_dir
  @dicts = grep {/\.dsl/} read_dir("$dict_dir");
  @dicts = map { (my $s = $_) =~ s/\.dsl//; $s} @dicts;
}

my $search = &detone(lc(shift @ARGV));        # Only the search term is left in ARGV

foreach my $dict (@dicts){
  my $dict_file = $dict_dir . $dict . '.dsl';
  die "$dict_file not found" unless -e $dict_file;
  my $dict_index = $idx_dir . $dict . '.db';
  die "$dict_index not found" unless -e $dict_index;
  my %w_index;
  my $dsn = qq(DBI:SQLite:dbname=$dict_index;,,,{ RaiseError=>1, AutoCommit=>1});
  my $dbh = DBI->connect($dsn) or die $DBI::errstr;

  my $sql = qq{SELECT HEAD, HEADWORD, OFFSET FROM $db_table WHERE HEAD LIKE ? };
  my $sth = $dbh->prepare($sql) or die ("Cannot Prepare:  " . $DBI::errstr);
  $sth->execute($search) or die("Cannot Execute: " . $DBI::errstr);

  my @w_matched = sort{ $a->[0] cmp $b->[0] } @{$sth->fetchall_arrayref()};


  if (scalar @w_matched){
    print "\x1b[33;1m$dict\x1b[0m:\n";
  } else {
    print "\x1b[33;1m$dict\x1b[0m: -\n";
    next;                                         # Stop if nothing in index
  }

  open (IN, '<', $dict_file) or die $!;
  foreach ( @w_matched) {
    my ($head, $word, $idx) = @$_;
    seek IN, $idx, 0;
    my $body = "";
    while(1){
      my $indent = 1;                                # default value
      my $line = <IN> ;
      last unless $line =~ /\t(?:\[(m\d?)\])?/;
      my $level = $1;
      if ($level)
      {
        $indent = 1 if $level eq 'm0';
        $indent = 2 if $level eq 'm1';
        $indent = 4 if $level eq 'm2';
        $indent = 8 if $level eq 'm3';
        $indent = 10 if $level eq 'm4';
      }
      $line =~ s/\s*\[\/?m\d?\]//g;
      &colour_Ansi($line);                                # Markups -> colour
      $body .= ( ' ' x $indent) . $line;
      # last unless $regex_flag;
    }
    print "\x1b[35;1m", decode_utf8($word), "\x1b[0m", ": ";
    print "$body\n";
  }
  close IN;
  $dbh->disconnect();
} # --- end foreach $dic

#-----------------------------------------------------------
#               Subroutines
#-----------------------------------------------------------

sub colour_Ansi
{
  my $reset='[0m';
  my $red='[0;31m';
  my $green='[0;32m';
  my $yellow='[0;33m';
  my $blue='[0;34m';
  my $purple='[0;35m';
  my $cyan='[0;36m';

  $_[0] =~ s/\[\/?i\]//g;                        # Italics out
  $_[0] =~ s/\[c\s+(?:\w+?)?green\]/$green/g;
  $_[0] =~ s/\[c\s+(?:\w+?)?blue\]/$blue/g;
  $_[0] =~ s/\[c\s+(?:\w+?)?magenta\]/$purple/g;
  $_[0] =~ s/\[c\s+(?:\w+?)?purple\]/$purple/g;
  $_[0] =~ s/\[c\s+(?:\w+?)?red\]/$red/g;
  $_[0] =~ s/\[c maroon\]/$red/g;
  # $_[0] =~ s/(\[c gray\])|(\[p\])/$cyan/g;
  $_[0] =~ s/(\[c\s+(?:\w+?)?gray\])|(\[p\])/$cyan/g;
  $_[0] =~ s/\[c\s+(?:\w+?)?yellow\]/$yellow/g;
  $_[0] =~ s/\[b\]/$yellow/g;
  $_[0] =~ s/\[ref]/$cyan/g;
  $_[0] =~ s/\[\/[bcp]\]/$reset/g;
  $_[0] =~ s/\[\/ref]/$reset/g;
  $_[0] =~ s/\\</</g;
  $_[0] =~ s/\\>/>/g;
  $_[0] =~ s/\\~/~/g;
  $_[0] =~ s!\[/?ex]!!g;
  $_[0] =~ s!\[/?trn]!!g;
  $_[0] =~ s!\[/?lang(?: id=\d+)?]!!g;
  $_[0] =~ s!\[/?c(?: [a-z]+)?\]!!g;
  $_[0] =~ s/\\\[/{/g;                          # \[ -> [
  $_[0] =~ s/\\\]/}/g;                          # \] -> ]

}

#-----------------------------------------------------------

sub decolour
{
  $_[0] =~ s/\[\/?c.*?\]//g;
  $_[0] =~ s/\[\/?b\]//g;

}

#-----------------------------------------------------------

sub dict_indexer
{
  use Parallel::ForkManager;
  my $pm = Parallel::ForkManager->new(7);
  my $dict_dir = shift @_;
  print "Indexing dictionaries in $dict_dir  ...\n";
  my @dicts = grep {/\.dsl/} read_dir("$dict_dir");
  @dicts = map { (my $s = $_) =~ s/\.dsl//; $s} @dicts;
  # $| = 1;
  foreach my $dict (@dicts){
    my $pid = $pm->start and next;
    my $dict_file = $dict_dir . $dict . '.dsl';
    my $dict_index = $idx_dir . $dict . '.db';
    unlink $dict_index if -e $dict_index;

    print "$dict ...";
    my @stopwords = qw/and ÎºÎ±Î¹ Î¼ÎµÎ½ Î´Îµ Î¿ Î· Ï„Î¿ Ï„Î¿Ï… Ï„Î·Ï‚ Ï„Ï‰Î½ Î±Î¹ Î¿Î¹ Ï„Î± ÎµÎ½ Ï‰/;
    my $dsn = qq(DBI:SQLite:dbname=$dict_index;,,,{ RaiseError=>1, AutoCommit=>1});
    my $dbh = DBI->connect($dsn) or die $DBI::errstr;
    $dbh->do("PRAGMA synchronous = OFF");             # otherwise insertions are too slow
    my $tbl = qq{ CREATE TABLE IF NOT EXISTS $db_table
                      (ID INTEGER PRIMARY KEY NOT NULL,
                        HEAD TEXT,
                        HEADWORD TEXT,
                        OFFSET  INTEGER NOT NULL);
                };
    my $rv = $dbh->do($tbl);
    die ("Table creation error" . $DBI::errstr) if $rv < 0;
    #
    # Prepare insertion command
    #
    my $sql = qq{INSERT INTO $db_table (HEAD, HEADWORD, OFFSET) VALUES(?, ?, ?);};
    my $sth = $dbh->prepare($sql) or die("cannot prepare: " . $DBI::errstr);

    my %w_index;
    my %dups;
    my $offset = 0;
    my $head;
    my $d_head;
    my $body_lines = 1;
    my @prev_d_heads= ();               # Store detoned heads for bodyless lemmata
    open (IN, '<', $dict_file) or die $!;
    while (<IN>) {
      next if /#/;
      next if /^\s*$/;
      unless (/^\t/){
        push @prev_d_heads, $d_head;
        $offset = tell(IN);
        my $head = $_;
        $head =~ s/(\n|\r)//g;           # Need this for DOS \n\r. Chomp leaves \r
        $head =~ s/\x{feff}//;
        my @heads = split /\s+/, $head;
        foreach (@heads){
          $d_head = &detone($_);
          $d_head =~ s/(\,|\.)$//;
          next if $d_head ~~ @stopwords;       # Do not enter stop words
          unless (exists $w_index{$d_head}){
            $w_index{$d_head} = [$offset, $head];
          }else{
            if (exists($dups{$d_head})){
              $dups{$d_head}++;
              $w_index{$d_head . "-" ."$dups{$d_head}"} = [$offset, $head];
            }else{
              $dups{$d_head} = 1;
              $w_index{$d_head . "-1"} = [$offset, $head];
            }
          }  # -- End unless exists
        }

        #-------------------------------------------------------------
        #      Offsets of bodyless lemmata are set to the first
        #      lemma that has a body.  Good for Beeks but may give
        #      silly results in other dictionaries
        #-------------------------------------------------------------
        if ($body_lines eq 0){
          @{$w_index{$_}}[0] = $offset foreach (@prev_d_heads);
        }
        $body_lines = 0;                  # Reset lines counter
      } else {
        $body_lines++;
        @prev_d_heads =();                # Reset

      }  # -- End unless /^t/
    }
    close IN;
    my (@d_heads, @indexes, @heads);
    foreach my $entry (sort keys %w_index){
      push @indexes, $w_index{$entry}->[0];
      push @heads,   $w_index{$entry}->[1];
      $entry =~ s/\-\d+$//;                 # Remove -{1,2,3}
      push @d_heads, $entry;
    }
    # my @d_heads = keys %w_index;
    # s/\-\d+$// foreach @d_heads;
    # my @values = values %w_index;
    # my @indexes = map { $_->[0] } @values;
    # my @heads = map { $_->[1] } @values;
    $sth->execute_array({}, \@d_heads, \@heads, \@indexes);
    $sth->finish;
    $dbh->disconnect();
    print " Completed\n";
    $pm->finish;
  }  # end foreach @dict
  $pm->wait_all_children;
  say "All done.";
  return;
}

#-----------------------------------------------------------

use Unicode::Normalize;
sub detone
{
  my $head = shift @_;
  # $head =~ s/\{+\*\}+//g;
  $head =~ s/[\}\{\(\)\*\]\[\\]+//g;
  $head =~ s/[0-9]+?\.?//g;
  $head = NFD($head);
  $head =~ s/\pM*//g;
  $head = lc $head;
  $head =~ s/\s+/ /;
  return $head;
}

#-----------------------------------------------------------

sub usage
{
  print << 'EOT';
  +--------------------------------------------------------------------------+
  |                                                                          |
  |                                                                          |
  |     Usage:  ./lectus <lemma>  [option]                                   |
  |                                                                          |
  |     OPTIONS:                                                             |
  |     -i or --index               Index all dictionaries                   |
  |     -l or --lexica              Space separated list of dictionaries     |
  |     -d or --directory           Path to the dictionaries directory       |
  |                                 Default directory path:  ./              |
  |                                                                          |
  +--------------------------------------------------------------------------+
EOT
die;
}
