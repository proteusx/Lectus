#!/usr/bin/perl -w -CSDA

use strict;
use utf8;
use v5.010;
use Unicode::Collate;
use Storable;
use File::Slurp qw(read_dir);
use Getopt::Long;

&usage unless scalar(@ARGV);                  # Error return if no args at all
my $uc = Unicode::Collate->new();

my $regex_flag = 0;
my @dicts;

GetOptions(
  'regex!'                => \$regex_flag,
  'dictionaries=s{1,}'    => \@dicts,
) or &usage;                                  # Error return if otions fault

&usage unless scalar(@ARGV);                  # Error return if no search term
my $search_regex = shift @ARGV;               # Only search term left in ARGV

unless (scalar @dicts){                       # Look for DSLs in the working dir
  @dicts = grep {/\.dsl/} read_dir('./');
  @dicts = map { (my $s = $_) =~ s/\.dsl//; $s} @dicts;
}

my $max_matches = 20;                          # Maximum lemata to return
my $lemma;
foreach my $dict (@dicts){
  my $dict_file = $dict . '.dsl';
  my $dict_index = $dict.'.idx';
  my %w_index;
  my @w_matches;

  &dict_indexer($dict) unless -e $dict_index;      # Generate index if not there
  say "\x1b[33;1m$dict\x1b[0m";

  %w_index = %{retrieve($dict_index)};
  my $n = 0;                                       # Lemma counter
  foreach my $d_head ( keys %w_index){
    unless ($regex_flag){
      $lemma = qr/^$search_regex-?\d?$/;
    }else{
      $lemma = qr/$search_regex/;
    }
    # say $lemma; die;
    if ($d_head =~ m/$lemma/){
        push @w_matches, $d_head;
        $n++;
    }
    last if $n >= $max_matches;
  }
  unless ($n){
    print "No matches for $search_regex\n\n";
    next;
  }
  open (IN, '<', $dict_file) or die $!;
  foreach ($uc->sort( @w_matches)){
    # say $_;
    my ($idx, $word) = @{$w_index{$_}};            # [index, word]
    seek IN, $idx, 0;
    my $body = "";
    while(1){
      my $line = <IN> ;
      last unless $line =~ /\t\[m\d\]/;
      $line =~ s/\s*\[\/?m\d?\]//g;
      # chomp $line;
      $body .= $line;
    }
    # $body =~ s/\s*\[\/?m\d?\]//g;
    &colour($body);                                # Markups -> colour
    # &decolour($body);                            # Remove colour markups.

    print "\x1b[35;1m", $word, "\x1b[0m", ": ";
    print "$body\n";
  }
  # say foreach @w_matches;
  close IN;
  print"\n";
} # --- end foreach $dic

#-----------------------------------------------------------
#               Subroutines
#-----------------------------------------------------------

sub colour
{
  # $_[0] =~ s/\[c.*?\]/\x1b[36;1m/g;
  $_[0] =~ s/\[c limegreen\]/\x1b[32;1m/g;
  $_[0] =~ s/\[c darkblue\]/\x1b[34;1m/g;
  $_[0] =~ s/\[c darkmagenta\]/\x1b[35;1m/g;
  $_[0] =~ s/\[c maroon\]/\x1b[31;1m/g;
  $_[0] =~ s/\[c gray\]/\x1b[36;1m/g;
  $_[0] =~ s/\[c red]//g;
  $_[0] =~ s/\[\/c\]/\x1b[0m/g;
  $_[0] =~ s/\[b\]/\x1b[35;1m/g;
  $_[0] =~ s/\[\/b\]/\x1b[0m/g;
  $_[0] =~ s/\[\/?i\]//g;
  $_[0] =~ s/\\\[/\[/g;
  $_[0] =~ s/\\\]/\]/g;

}

#-----------------------------------------------------------

sub decolour
{
  $_[0] =~ s/\[\/?c.*?\]//g;
  $_[0] =~ s/\[\/?b\]//g;

}

#-----------------------------------------------------------

sub dict_indexer
{
  my $dict = shift @_;
  my $dict_idx = $dict . '.idx';

  my %w_index;
  my %dups;
  my $offset = 0;
  my $head;
  my $d_head;
  my $body_lines = 1;
  my @prev_d_heads= ();       # Store detoned heads for bodyless lemmata
  open (IN, '<', $dict . '.dsl') or die $!;
  while (<IN>) {
    next if /#/;
    next if /^\s*$/;
    unless (/^\t/){
      push @prev_d_heads, $d_head;
      $offset = tell(IN);
      $head = $_;
      $head =~ s/(\n|\r)//g;    # Need this for DOS \n\r. chomp leaves \r
      $head =~ s/\x{feff}//;
      $d_head = &detone($head);
      unless (exists $w_index{$d_head}){
        $w_index{$d_head} = [$offset, $head];
      }else{
        if (exists($dups{$d_head})){
          $dups{$d_head}++;
          $w_index{$d_head . "-" ."$dups{$d_head}"} = [$offset, $head];
        }else{
          $dups{$d_head} = 1;
          $w_index{$d_head . "-1"} = [$offset, $head];
        }
      }  # -- End unless exists

      #-------------------------------------------------------------
      #      Offsets of bodyless lemmata are set to the first
      #      lemma that has a body.  Good for Beeks but may give
      #      silly results in other dictionaries
      #-------------------------------------------------------------
      if ($body_lines eq 0){
        @{$w_index{$_}}[0] = $offset foreach (@prev_d_heads);
      }
      $body_lines = 0;                  # Reset lines counter
    } else {
      $body_lines++;
      @prev_d_heads =();                # Reset

    }  # -- End unless /^t/
  }
  store \%w_index, $dict_idx;
  close IN;
  say "$dict.dsl indexed -> $dict_idx";
  return;
}

#-----------------------------------------------------------

use Unicode::Normalize;
sub detone
{
  my $head = shift @_;
  # $head =~ s/\{+\*\}+//g;
  $head =~ s/[\}\{\(\)\*]+//;
  $head =~ s/[0-9]+//;
  $head = NFD($head);
  $head =~ s/\pM*//g;
  $head = lc $head;
  $head =~ s/\s+//;
  return $head;
}

#-----------------------------------------------------------

sub usage
{
  print << 'EOT';
  +--------------------------------------------------------------------------+
  |                                                                          |
  |                                                                          |
  |     Usage:  ./lectus <lemma> [option]                                    |
  |                                                                          |
  |     OPTIONS:                                                             |
  |     -r or --regex               Toggle search by regular expression      |
  |     -d or --dictionaries        Space separated list of dictionaries     |
  |                                                                          |
  |                                                                          |
  +--------------------------------------------------------------------------+
EOT
die;
}
